JDK - компилирует
JRE - окружение для исполнения программы
JVM - исполняет программу

javac -sourcepath ./src -d out src/MainPackage/Main.java
java -classpath ./out  MainPackage.Main


###### Очень важные строки
docker build -t java-app:demo .
docker images
docker run -it java-app:demo

## Примитивные типы

boolean - хранит неопределённое колличество памяти(зависит от jvm) но обычно считается что он хранит байт

**Разберём строку:**
char myChar = 'H';
1. char myChar = 'H'; - это инициализация
2. char myChar - это определение(обьявление)
3. char - это тип
4. myChar - это индетификатор(имя)
5. = - знак присваивания
6. 'H' - это значение

## Ссылочные типы

Это тип имеющий внутри себя ссылку, может иметь значение null.

### Массив 
Это тип имеющий ссылочное значение который ссылается на элементы массива.

int[] array3 = {5, 4, 3, 2, 1};
int[] array2 = new int[5];
int[] array1 = array2;
int[] array0;

#### Final и array 
Если: final int[] array;
То:  Не можем: array = int[] array2;
То:  Можем: array[1] = 5;

#### Не прямоугольные массивы возможны для java

При пересоздании размера массивов нижних уровней в многомерном массиве

#### Индекс это значение смещение относительно начала массива

## Операции java

Опреации в java происходит по таким приоритетам - сначала деление и умножение, слева на право, присваивание в самом конце.

### Битый не битового везёт

! - Логическое “не” (отрицание)
~ - Логическое “не” (отрицание) (битовая операция)
& - Логическое И (AND, умножение)(битовая операция)
| - Логическое ИЛИ (OR, сложение)(битовая операция)
^ - Логическое исключающее ИЛИ (XOR)(битовая операция)
&& - Условное И (сокращённое логическое И)
|| - Условное ИЛИ (сокращённое логическое ИЛИ)

## Методы java

### Почему методы а не функции
Функции внутри классов называются методами, все функции внутри Java внутри классов

### Что такое метод в java

Имя метода - это переходный глагол совершенного вида в настоящем времени.(Вернуть)(Посчитать)(Установить)(Создать)(Ввести).

Нельзя писать функции внутри функций.

Аргументы метода это ссылка на передаваемый обьект.

### Сигнатура метода

Сигнатура метода - это имя метода и его параметры. В сигнатуру метода не входит возращаемое значение. 

Нельзя написать два метода с одинаковой сигнатурой. (С одинаковым именем + колличеством параметров + типами параметров)

# Class
Класс - логическая конструкция для строительства языка джава(шаблон по которому создаются обьекты)

**Разберём строку:**
Cat cat1 = new Cat();
1. Cat cat1 = new Cat(); - это инициализация экземпляра обьекта Cat
2. Cat - тип обьекта который надо инициализировать
3. new - это оператор для динамического выделения памяти и передачи ссылки нового созданного обьекта в переменную cat
4. Cat() - это конструктор класса Cat может иметь разное колличество переменных для инициализации обьекта.

## Класс это ссылочный тип

[Пример того что перменные экземпляров класса хранят только ссылки на экземпляр](Lesson003/Ex002/src/Main.java)

## Статические методы и поля

Статические методы и поля - принадлекат не экземпляру класса а классу.

По факту их можно считать констатными полями на которые хранится ссылка в каждом обьекте

[Пример того статические переменные нельзя использовать экзеплярами класса](Lesson003/Ex003/src/Main.java)

# Распределение памяти

JVM делит память на стки и кучи.

- Приложение стек и куча всё время обмениваються друг с другом данными.

- Стек - Хранит ссылки на обьекты кучи и за хранение примитивных значений по патену LIFO(Last-In, First-Out). Переменные в стеки имею зону видимости например класса или метода. Заканчивая работу в методу верхняя часть кучи отбрасывается и заполняется новая для изменения зоны видимости. Каждый поток имеет свой стек.(Доступ к стеку)
![Информация о стеке](1.png)
- Куча - Содержит все обьекты созданные в нашем приложении. Со всеми своими данными внутри. Когда локальная переменная(или обьект) ссылочная ссылка храниться в стеке а примитивный обьект(или метод) в куче(но в методе могут быть локальные переменные которые опять будут хранится в стеке).
Доступ к куче медленее(она для всех потоков одна).
Куча разбита на поколения:
- Young Generation - Недавно созданные обьекты.(Когда она заполняется происходит быстрая сборка мусора)
- Old(Tenured) Generation - Долгоживущие обьекты.
- Permanent Generation - Постоянные обьекты.(С java 8 заменена на MetaSpace динамический аналог)
![Информация о куче](2.png)

## Сборка мусора

1. Это процесс запускается автоматически Java, и Java решает, запускать или нет этот процесс.
2. На самом деле это дорогостоящий процесс. При запуске сборщика мусора все потоки в вашем приложеии приостанавливаются(В зависимости от типа GC).
3. На самом деле это гораздо более сложный процесс, чем просто сбор мусора и освобождение памяти.

![Информация о памяти](3.png)

Сборка мусора в Java останавливает все потоки. Сборка мусора бывает двух типов.
- Быстрая - эта сборка мусора в молодом поколении. В этот момет все кого не собрали в мусор помещаются в отдельное поле выживших, а молодая куча запускается новыми значениями. И уже в следующий раз сборщик мусора берёт часть из кучи выживших и часть из кучи молодых для помещения их в новую кучу выживших.
- Медленная - это сборка мусора в старом поколении и происходит она намного меньше так как затрачивает намного больше ресурсов. 

Виды сборщиков мусора(garbage collector(GC)): 
1. Последовательный - самый обычный.(Не использовать при многопоточности)
2. Паралельный - использует несколько потоков.
3. CMS - приложения на нём работаю медленее но не останавливаются во время сборки мусора. Явный вызов сборки мусора приведёт к прерыванию параленого режима.
4. G1 - предназначен для мощных компьютеров.
5. ZGC - масштабируемый мощный сборщик мусора.

# Полезные ссылки
![https://gbcdn.mrgcdn.ru/uploads/asset/5324332/attachment/888420c348a5d39c4e11498dc4628c30.pdf](ВотОна)

Презентация https://docs.google.com/presentation/d/15EH3ZQFDurYhfpBN0FH_802XvVD66fMl9cQc-GgZgl0/edit?usp=sharing

Задание про интернет-магазин:

Класс «Эмуляция интернет-магазина».
1. Написать классы покупатель (ФИО, возраст, телефон), товар (название, цена) и
заказ (объект покупатель, объект товар, целочисленное количество).
2. Создать массив покупателей (инициализировать 2 элемента), массив товаров
(инициализировать 5 элементов) и массив заказов (пустой на 5 элементов).
3. Создать статический метод «совершить покупку» со строковыми параметрами,
соответствующими полям объекта заказа. Метод должен вернуть объект заказа.
4. Если в метод передан несуществующий покупатель – метод должен выбросить
исключение CustomerException, если передан несуществующий товар, метод
должен выбросить исключение ProductException, если было передано отри-
цательное или слишком больше значение количества (например, 100), метод
должен выбросить исключение AmountException.

Вызвать метод совершения покупки несколько раз таким образом, чтобы запол-
нить массив покупок возвращаемыми значениями. Обработать исключения сле-
дующим образом (в заданном порядке):
– если был передан неверный товар – вывести в консоль сообщение об ошиб-
ке, не совершать данную покупку;
– если было передано неверное количество – купить товар в количестве 1;
– если был передан неверный пользователь – завершить работу приложения
с исключением.

Вывести в консоль итоговое количество совершённых покупок после выполне-
ния основного кода приложения.